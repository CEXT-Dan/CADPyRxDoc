<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PyAp.pyi</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Consolas, monospace;
            margin: 2em;
        }
        a {
            color: #569cd6;
        }
        .class {
            margin-bottom: 1em;
        }
        summary {
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        details {
            margin-left: 0.5em;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 0.5em;
        }
        code {
            display: block;
            margin: 0.3em 0;
            white-space: pre;
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4em 0.6em;
            border-left: 4px solid #007acc;
            font-size: 1.2em;
        }
        .kw {
            color: #569cd6;
            font-weight: bold;
        }
        h1 {
            color: #569cd6;
        }
        .tag {
            background: #007acc;
            color: #fff;
            border-radius: 4px;
            padding: 0.1em 0.5em;
            font-size: 0.9em;
            margin-left: 0.5em;
        }
        .toc {
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <h1>PyAp.pyi</h1>
    <div class="toc">
        <h2>Classes</h2>
        <ul>
            <li><a href="#Application">Application</a></li>
            <li><a href="#AutoDocLock">AutoDocLock</a></li>
            <li><a href="#CmdFlags">CmdFlags</a></li>
            <li><a href="#DocLockMode">DocLockMode</a></li>
            <li><a href="#DocManager">DocManager</a></li>
            <li><a href="#DocManagerReactor">DocManagerReactor</a></li>
            <li><a href="#Document">Document</a></li>
            <li><a href="#LayerFilter">LayerFilter</a></li>
            <li><a href="#LayerFilterManager">LayerFilterManager</a></li>
            <li><a href="#LayerGroup">LayerGroup</a></li>
            <li><a href="#LayoutManager">LayoutManager</a></li>
            <li><a href="#Palette">Palette</a></li>
            <li><a href="#PaletteDockStyle">PaletteDockStyle</a></li>
            <li><a href="#PaletteSet">PaletteSet</a></li>
            <li><a href="#PaletteTitleBarLocation">PaletteTitleBarLocation</a></li>
            <li><a href="#PyRxTestFlags">PyRxTestFlags</a></li>
            <li><a href="#ResourceOverride">ResourceOverride</a></li>
            <li><a href="#SaveFormat">SaveFormat</a></li>
            <li><a href="#TransactionManager">TransactionManager</a></li>
        </ul>
    </div>

    <div class="class" id="Application">
        <details>
            <summary>class Application <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> acadApplication() -&gt; PyAx.AcadApplication</code>
            <code><span class="kw">def</span> acadGetIDispatch() -&gt; int</code>
            <code><span class="kw">def</span> applyHostIcon(wnd: int) -&gt; None</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> docManager() -&gt; DocManager</code>
            <code><span class="kw">def</span> getAppDataPath(createIfNotFound: bool) -&gt; str</code>
            <code><span class="kw">def</span> getLoadedModuleNames() -&gt; list[str]</code>
            <code><span class="kw">def</span> getLoadedModules() -&gt; list[str]</code>
            <code><span class="kw">def</span> getLocalAppDataPath(createIfNotFound: bool) -&gt; str</code>
            <code><span class="kw">def</span> getPyRxModuleName() -&gt; str</code>
            <code><span class="kw">def</span> getPyRxModulePath() -&gt; str</code>
            <code><span class="kw">def</span> hostAPI() -&gt; str</code>
            <code><span class="kw">def</span> hostAPIVER() -&gt; str</code>
            <code><span class="kw">def</span> hostFileInfo() -&gt; str</code>
            <code><span class="kw">def</span> listFilesInPath(path: str, ext: str) -&gt; list</code>
            <code><span class="kw">def</span> listFilesInPathRecursive(path: str, ext: str) -&gt; list</code>
            <code><span class="kw">def</span> loadPythonModule(fullpath: str) -&gt; object</code>
            <code><span class="kw">def</span> mainWnd() -&gt; int</code>
            <code><span class="kw">def</span> pyrxVersion() -&gt; str</code>
            <code><span class="kw">def</span> regCommand(fullpath: str, modulename: str, name: str, defFunc: Any, flags: PyAp.CmdFlags) -&gt; None</code>
            <code><span class="kw">def</span> registerOnIdleWinMsg(func: Any) -&gt; None</code>
            <code><span class="kw">def</span> registerWatchWinMsg(func: Any) -&gt; bool</code>
            <code><span class="kw">def</span> reloadPythonModule(fullpath: str) -&gt; object</code>
            <code><span class="kw">def</span> removeCommand(modulename: str, name: str) -&gt; None</code>
            <code><span class="kw">def</span> removeOnIdleWinMsg(func: Any) -&gt; None</code>
            <code><span class="kw">def</span> removeWatchWinMsg(func: Any) -&gt; bool</code>
            <code><span class="kw">def</span> setTitleThemeDark(wnd: int) -&gt; None</code>
            <code><span class="kw">def</span> showModalDialog(window: wx.Dialog) -&gt; int</code>
            <code><span class="kw">def</span> testFlags(flags: PyAp.PyRxTestFlags) -&gt; str</code>
            <code><span class="kw">def</span> wxApp() -&gt; object</code>
        </details>
    </div>

    <div class="class" id="AutoDocLock">
        <details>
            <summary>class AutoDocLock <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, docToLock: PyAp.Document) -&gt; None
    &quot;&quot;&quot;This function is used for locking documents in order to access their resources. Resources
include all AcDbDatabases objects associated with a document, and AcDbObject objects in
those databases, and all AcDbDatabase resident system variables. It also includes all
document based system variables, and the Transaction Manager associated with a document.
The document does not need to be locked to open an AcDbObject in AcDb::kForRead, nor to get
system variables. Applications should normally never have to lock or unlock the current
document. Commands registered with addCommand() or aceddefun() will have the current
document locked before starting, and unlocked after ending. This can be controlled using
the addCommand() function tags.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> doc(self) -&gt; Document</code>
        </details>
    </div>

    <div class="class" id="CmdFlags">
        <details>
            <summary>class CmdFlags <span class="tag">Class</span></summary>
            <code>DEFUN: int</code>
            <code>DOCEXCLUSIVELOCK: int</code>
            <code>DOCREADLOCK: int</code>
            <code>INPROGRESS: int</code>
            <code>INTERRUPTIBLE: int</code>
            <code>MODAL: int</code>
            <code>NOBEDIT: int</code>
            <code>NOHISTORY: int</code>
            <code>NOINTERNALLOCK: int</code>
            <code>NOMULTIPLE: int</code>
            <code>NOOEM: int</code>
            <code>NOPAPERSPACE: int</code>
            <code>NOPERSPECTIVE: int</code>
            <code>NOTILEMODE: int</code>
            <code>NO_UNDO_MARKER: int</code>
            <code>REDRAW: int</code>
            <code>SESSION: int</code>
            <code>TRANSPARENT: int</code>
            <code>UNDEFINED: int</code>
            <code>USEPICKSET: int</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
        </details>
    </div>

    <div class="class" id="DocLockMode">
        <details>
            <summary>class DocLockMode <span class="tag">Class</span></summary>
            <code>kNone: ClassVar[Self]</code>
            <code>kAutoWrite: ClassVar[Self]</code>
            <code>kNotLocked: ClassVar[Self]</code>
            <code>kWrite: ClassVar[Self]</code>
            <code>kProtectedAutoWrite: ClassVar[Self]</code>
            <code>kRead: ClassVar[Self]</code>
            <code>kXWrite: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="DocManager">
        <details>
            <summary>class DocManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;The AcApDocumentManager object is the container for all the document objects (there is one
document object for each drawing that is open and being edited). There is only one
instance, which can be obtained using the macro named acDocManager.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> activateDocument(self, doc: PyAp.Document, bPassScript: bool) -&gt; None
    &quot;&quot;&quot;This function will switch from the current document to another document. The function will
NOT suspend execution of the code running under the application context. The caller is
suspended if it is a normal or nomadic context. If the bPassScript is Adesk::kTrue, then
the script that has called the command that is performing a document change will continue
to run. This argument allows a script to continue running across documents.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> appContextCloseDocument(self, doc: PyAp.Document) -&gt; None
    &quot;&quot;&quot;Immediately destroys the active document and a lot of related data. Caution: Since the
document is destroyed, beware of what you reference after the call.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> appContextNewDocument(self, templateName: str) -&gt; None
    &quot;&quot;&quot;This function allows synchronous access to the NEW drawing operation. It can only be called
from the application context.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> appContextOpenDocument(self, dwgName: str) -&gt; None
    &quot;&quot;&quot;This function allows synchronous access to the OPEN drawing operation. It can only be
called from the application context. Based pParams, you can switch to a layout or view
after the opening of the drawing.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> appContextPromptOpenDocument(self) -&gt; None
    &quot;&quot;&quot;This function allows synchronous access to the OPEN drawing operation. It can only be
called from the application context. Similar to appContextOpenDocument(), expect it prompts
for a drawing name.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> appContextRecoverDocument(self, dwgName: str) -&gt; None
    &quot;&quot;&quot;This function allows synchronous access to the RECOVER drawing operation. It can only be
called from the application context. When running, no dialogs or prompts requiring user
interaction will be required.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> autoLock(docToLock: PyAp.Document) -&gt; AutoDocLock
    &quot;&quot;&quot;This function is used for locking documents in order to access their resources. Resources
include all AcDbDatabases objects associated with a document, and AcDbObject objects in
those databases, and all AcDbDatabase resident system variables. It also includes all
document based system variables, and the Transaction Manager associated with a document.
The document does not need to be locked to open an AcDbObject in AcDb::kForRead, nor to get
system variables. Applications should normally never have to lock or unlock the current
document. Commands registered with addCommand() or aceddefun() will have the current
document locked before starting, and unlocked after ending. This can be controlled using
the addCommand() function tags.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> beginExecuteInApplicationContext(self, func: Any, data: Any) -&gt; PyDb.ErrorStatus
    &quot;&quot;&quot;Allows anonymous code execution in command context (same as registering a command and
calling sendStringToExecute to invoke it.). The command will be executed in the context of
the MDI active document. The callback function will be called when the system has a chance
to execute a command. This, at minimum, means that the caller of
beginExecuteInCommandContext (i.e. your code) must return to its caller. All outstanding
commands will be cancelled before the callback function is invoked.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> beginExecuteInCommandContext(self, func: Any, data: Any) -&gt; PyDb.ErrorStatus
    &quot;&quot;&quot;Allows anonymous code execution in command context (same as registering a command and
calling endStringToExecute to invoke it.). The command will be executed in the context of
the MDI active document. The callback function will be called when the system has a chance
to execute a command. This, at minimum, means that the caller of
beginExecuteInCommandContext (i.e. your code) must return to its caller. All outstanding
commands will be cancelled before the callback function is invoked.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> closeDocument(self, doc: PyAp.Document) -&gt; None
    &quot;&quot;&quot;This function closes the document specified by pAcTargetDocument. If the input document is
not the current document, current document retains control. If input document is the
current document, the document execution context is terminated before this function
returns, terminating normal commands.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> curDocument(self) -&gt; Document
    &quot;&quot;&quot;This function returns the document having current context. The associated function,
mdiActiveDocument(), returns the MDI active document. curDocument() and mdiActiveDocument()
can be different. You can call curDocument() to make a document &#x27;current&#x27; without actually
activating it. After finish your AcDbDatabase operation under the temporary current
document, call setCurDocument(acDocManager-&gt;mdiActiveDocument()) to reset the MDI active
document as the current document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> defaultFormatForSave(self) -&gt; SaveFormat
    &quot;&quot;&quot;This function returns the current default save format.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> disableDocumentActivation(self) -&gt; None
    &quot;&quot;&quot;This function will disable the ability for the user to switch to another document.
Applications must be sure to restore activation (using
AcApDocManager::enableDocumentActivation) when complete. An example use might be when an
application command is processing for long periods of time. Returns an error when already
in a disabled mode; otherwise, returns Acad::eOk.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> document(self, db: PyDb.Database) -&gt; Document
    &quot;&quot;&quot;This function returns the document that the input database belongs to. All databases
created in ObjectARX, the current database, and any loaded Xref databases will have a
document that they are associated with. Databases created by ObjectARX applications will be
automatically associated with the document of the context in which they were created. This
is then the document that the database will have its Undo recorded. It is also the document
whose Transaction Manager must be used for objects from the database.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentCount(self) -&gt; int
    &quot;&quot;&quot;This function returns the number of documents currently open.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documents(self) -&gt; list[PyAp.Document]</code>
            <code><span class="kw">def</span> enableDocumentActivation(self) -&gt; None
    &quot;&quot;&quot;This function will enable the ability for the user to switch to another document. This
function is used to re-enable activation after a call to
AcApDocManager::disableDocumentActivation. Returns an error when already in an enabled
mode; otherwise, returns Acad::eOk.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> executeInApplicationContext(self, func: Any, data: Any) -&gt; None
    &quot;&quot;&quot;Allows a void function to be called from the application context.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> inputPending(self, doc: PyAp.Document) -&gt; int
    &quot;&quot;&quot;This function will determine the state of the document&#x27;s input buffer. Used only in
conjunction with the AcApDocManager::sendStringToExecute function. Returns the number of
characters waiting to be processed. A value of 0 indicates no pending input. A return value
of -1 indicates an error.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isApplicationContext(self) -&gt; bool
    &quot;&quot;&quot;This function is called by an executing function to determine if it is executing in the
application context.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isDocumentActivationEnabled(self) -&gt; bool
    &quot;&quot;&quot;This function indicates whether document activation is enabled. Returns true if enabled or
false otherwise.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> lockDocument(self, doc: PyAp.Document, mode: PyAp.DocLockMode, gcmd: str, lcmd: str, prmt: bool) -&gt; None
    &quot;&quot;&quot;This function is used for locking documents in order to access their resources. Resources
include all AcDbDatabases objects associated with a document, and AcDbObject objects in
those databases, and all AcDbDatabase resident system variables. It also includes all
document based system variables, and the Transaction Manager associated with a document.
The document does not need to be locked to open an AcDbObject in AcDb::kForRead, nor to get
system variables. Applications should normally never have to lock or unlock the current
document. Commands registered with addCommand() or aceddefun() will have the current
document locked before starting, and unlocked after ending. This can be controlled using
the addCommand() function tags.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> mdiActiveDocument(self) -&gt; Document
    &quot;&quot;&quot;This function returns the MDI active document. The associated function, curDocument(),
returns the document having current context. curDocument() and mdiActiveDocument() can be
different. You can call curDocument() to make a document &#x27;current&#x27; without actually
activating it. After finish your AcDbDatabase operation under the temporary current
document, call setCurDocument(acDocManager-&gt;mdiActiveDocument()) to reset the MDI active
document as the current document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> newDocument(self) -&gt; None
    &quot;&quot;&quot;This function creates a new document using standard user interface interaction.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> openDocument(self) -&gt; None
    &quot;&quot;&quot;This function opens a document using standard user interface interaction.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> popResourceHandle(self) -&gt; None
    &quot;&quot;&quot;This function makes the resource file handle on top of the stack current and removes it
from the stack.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pushAcadResourceHandle(self) -&gt; None
    &quot;&quot;&quot;This function pushes the current resource handle onto the current document&#x27;s resource
handle stack and makes the AutoCAD resource file current.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> sendModelessInterrupt(self, doc: PyAp.Document) -&gt; None
    &quot;&quot;&quot;This function causes the current command in the specified document to be interrupted if it
is prompting for input using one of the acedGetxxx functions and was registered with the
ACRX_CMD_INTERRUPTIBLE flag. Returns Acad::eOk if successful and Acad:eNoDocument if the
target document is not accessible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> sendStringToExecute(self, doc: PyAp.Document, script: str, bActivate: bool, bWrapUpInactiveDoc: bool, bEchoString: bool) -&gt; None
    &quot;&quot;&quot;Send string to target document to execute. By default, the string is executed in the
activate document. The string is executed as soon as possible when bActivate is false and
bWrapUpInactiveDoc is true. bEchoString determines whether the sent string is echoed on the
command line.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setCurDocument(self, doc: PyAp.Document, mode: PyAp.DocLockMode, activate: bool) -&gt; None
    &quot;&quot;&quot;This function allows an external application running under the Application context to make
a document &#x27;current&#x27; without actually activating it. This current state is only valid
during the context of the function calling this API. This enables safe manipulation of a
document&#x27;s data without the document actually being the top most or active document. The
default parameters lockMode and activate allow document locking and activation to occur.
These are shortcuts to allow several steps to be accomplished with a single API and can
also be accomplished with the individual API calls. If you call
acDocManager-&gt;setCurDocument(pDoc, AcAp::kWrite), you effectively set the current document
and lock it. You will need to unlock this document once you are done with it. You can do
this by calling acDocManager-&gt;unlockDocument(pDoc).&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setDefaultFormatForSave(self, fmt: PyAp.SaveFormat) -&gt; None
    &quot;&quot;&quot;This method uses one of the SaveFormat values to set the file format to use when saving a
drawing with the SAVEAS, SAVE, and QSAVE commands. This sets the session-wide default,
which the user may choose to override temporarily for an individual document. This method
directly sets the file format for interactive commands entered by the user. If you want
your application to use the current save format, every time you wish to save the database,
you will first need to call AcApDocument::formatForSave(), and then use the returned
SaveFormat value to determine which function to call. For example, if formatForSave()
returned kR12_dxf, you would call acdbDxfOutAsR12() to write the database as a Release 12
DXF file. In summary: Either you or your user may set a persistent session-wide default
format for save that will be honored by all save commands except AUTOSAVE. Only the user
can temporarily (not persistently between sessions) override this setting for a particular
document.The formatForSave() method returns the format in which the user wishes an
individual document to be saved, which will be either the session-wide default or the
temporary override, as appropriate.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> unlockDocument(self, doc: PyAp.Document) -&gt; None
    &quot;&quot;&quot;This function unlocks a previously locked document. Except for the kAutoWrite lock mode,
all locks applied with lockDocument() MUST be paired with an unlockDocument() call. Never
call unlockDocument() unless you have first had a successful lockDocument() call.
kAutoWrite should never be unlocked with unlockDocument().&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="DocManagerReactor">
        <details>
            <summary>class DocManagerReactor <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;This class provides notification for a variety of document management events.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addReactor(self) -&gt; None
    &quot;&quot;&quot;This function adds an AcApDocManagerReactor object to the document manager.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentActivated(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent once a document has been activated and its context has been
successfully switched.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentActivationModified(self, val: bool) -&gt; None
    &quot;&quot;&quot;This notification is sent for changes caused by disableDocumentActivation() or
enableDocumentActivation().&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentBecameCurrent(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent whenever the current document changes. It should not be confused
with a document getting focus, or becoming active. It is possible for the same document to
go in and out of focus, or become active and inactive. This notification is only sent when
a document becomes active, and is different than the last active document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentCreateCanceled(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent when a user action has canceled a document&#x27;s creation. This
notification is only sent in MDI mode and after a documentCreateStarted() notification.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentCreateStarted(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent when a document is first instantiated and no database is yet
available.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentCreated(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent when a new AcApDocument has been constructed. A new message in
acrxEntryPoint() can also be used by applications to monitor when a new document has been
started, but this method provides a pointer to the new AcApDocument.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentDestroyed(self, val: str) -&gt; None
    &quot;&quot;&quot;This notification is sent when a document is completely destroyed and the underlying
database corresponding to this document has also been deleted.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentLockModeChangeVetoed(self, doc: Document, globalCmdName: str) -&gt; None
    &quot;&quot;&quot;Requests to established locks on a document can be vetoed by reactors receiving the
documentLockModeChanged() callback. If this happens, then all reactors will receive this
callback so that all will know the request was vetoed, even though not all the reactors may
have received the documentLockModeChanged() callback before the veto occurred.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentLockModeChanged(self, doc: Document, myPrevMode: DocLockMode, myCurMode: DocLockMode, currentMode: DocLockMode, globalCmdName: str) -&gt; None
    &quot;&quot;&quot;This callback is given every time a lock is established or removed on a document. You can
distinguish between a lock or an unlock call. Unlock calls will always have a command name
prefixed with a &#x27;#&#x27; character. Lock calls can be vetoed, but unlock calls cannot.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentLockModeWillChange(self, myCurMode: DocLockMode, myNewMode: DocLockMode, curMode: DocLockMode, globalCmdName: str) -&gt; None
    &quot;&quot;&quot;This callback is given before all lock changes are made on documents. It cannot be vetoed.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentToBeActivated(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent when a document is about to be activated.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentToBeDeactivated(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent when a document is about to be deactivated.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> documentToBeDestroyed(self, val: Document) -&gt; None
    &quot;&quot;&quot;This notification is sent at the beginning of document destruction.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> removeReactor(self) -&gt; None
    &quot;&quot;&quot;This function removes the specified AcApDocManagerReactor object from the document manager.&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="Document">
        <details>
            <summary>class Document <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> autoLock(self) -&gt; AutoDocLock
    &quot;&quot;&quot;This function is used for locking documents in order to access their resources. Resources
include all AcDbDatabases objects associated with a document, and AcDbObject objects in
those databases, and all AcDbDatabase resident system variables. It also includes all
document based system variables, and the Transaction Manager associated with a document.
The document does not need to be locked to open an AcDbObject in AcDb::kForRead, nor to get
system variables. Applications should normally never have to lock or unlock the current
document. Commands registered with addCommand() or aceddefun() will have the current
document locked before starting, and unlocked after ending. This can be controlled using
the addCommand() function tags.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> database(self) -&gt; PyDb.Database
    &quot;&quot;&quot;Returns the database object (AcDbDatabase) being used by this AcApDocument.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> docTitle(self) -&gt; str
    &quot;&quot;&quot;Returns the window title of the document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> docWnd() -&gt; int</code>
            <code><span class="kw">def</span> downgradeDocOpen(self, promptForSave: bool) -&gt; None
    &quot;&quot;&quot;Converts the document status from writeable to read only. If bPromptForSave is true and the
drawing is modified (based on dbmod), the user is prompted to save the drawing. If
bPromptForSave is false and the drawing has been modified, an error is returned.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> editor(self) -&gt; PyEd.Editor</code>
            <code><span class="kw">def</span> fileName(self) -&gt; str
    &quot;&quot;&quot;Returns the full path and file name of the database being used by this AcApDocument.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> formatForSave(self) -&gt; SaveFormat
    &quot;&quot;&quot;This method returns the current save format that is being used by the SAVEAS, SAVE, and
QSAVE commands. The value returned may be either the session-wide default setting, or a
different setting that the user has selected for this document. If it is an override for
this document, it will not persist across sessions. This method directly returns the file
format for interactive commands entered by the user. If you want your application to use
the current save format, every time you wish to save the database, you will first need to
call formatForSave(), and then use the returned SaveFormat value to determine which
function to call. For example, if formatForSave() returned kR12_dxf, you would call
acdbDxfOutAsR12() to write the database as a Release 12 DXF file. In summary: Either you or
your user may set a persistent session-wide default format for save that will be honored by
all save commands except AUTOSAVE. Only the user can temporarily (not persistently between
sessions) override this setting for a particular document.The formatForSave() method
returns the format in which the user wishes an individual document to be saved, which will
be either the session-wide default or the temporary override, as appropriate.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getCountOfLispList(self) -&gt; int
    &quot;&quot;&quot;Returns number of loaded LISP applications.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getItemOfLispList(self, index: int) -&gt; tuple[str, bool]
    &quot;&quot;&quot;Accesses the list of loaded LISP applications and returns information corresponding to the
specified index.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getUserData(self) -&gt; object</code>
            <code><span class="kw">def</span> getWxWindow() -&gt; object</code>
            <code><span class="kw">def</span> inputPointManager(self) -&gt; PyEd.InputPointManager
    &quot;&quot;&quot;This function will return this AcApDocument object&#x27;s input point manager object.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isCommandInputInactive(self) -&gt; bool
    &quot;&quot;&quot;This is isCommandInputInactive, a member of class AcApDocument.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isQuiescent(self) -&gt; bool
    &quot;&quot;&quot;This function determines if there is a command, LISP script, or ARX command active. Returns
true if there is no command, LISP script, or ARX command active; otherwise, it returns
false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> lockMode(self, bIncludeMyLocks: bool) -&gt; DocLockMode
    &quot;&quot;&quot;This function provides a way for an application to determine if it could have permission to
set a lock on a document. One rule about locking is that an execution context can override
any of its own locks. If this application&#x27;s context has an Exclusive Write lock, it can
still apply another lock to the document. Returns the highest level lock set by other
execution contexts if bIncludeMyLocks = false. If bIncludeMyLocks = true, then the function
will return the highest level lock set by any execution context, include this application.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> myLockMode(self) -&gt; DocLockMode
    &quot;&quot;&quot;This function returns the current lock status that the current execution has on the
document, and can be either stronger or weaker than that returned by
AcApDocument::lockMode().&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> popDbmod(self) -&gt; None
    &quot;&quot;&quot;This method pops the top value off of the DBMOD system variable stack and copies that value
into the document&#x27;s DBMOD system variable. popDbmod() will return eOk if successful,
eIllegalReplacement if the stack was empty, and eInvalidContext if the document is not
fully operational. eInvalidContext should only occur during early edit session
initialization, before the DBMOD value has been initialized.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pushDbmod(self) -&gt; None
    &quot;&quot;&quot;This method copies the current value of the DBMOD system variable onto a stack. This allows
you to save the current value of the DBMOD read-only system variable for subsequent
restoration through the popDbmod() method. pushDbmod() and its counterpart popDbmod() allow
your application to modify a database without having it marked as modified, as is commonly
done by applications during edit session initialization. This includes modification of
database header variables or adding to and modifying objects in the database being edited,
which all cause flags in the document system variable DBMOD to be set. When DBMOD is
non-zero, the &#x27;Save your drawing?&#x27; prompt is posted when a user attempts to quit out of a
drawing. To avoid this prompt in your application, stack the current DBMOD value with
pushDbmod() before beginning to modify the database in a manner that should not cause this
query, restore DBMOD with popDbmod() when such modifications are complete.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setDocTitle(self, title: str) -&gt; None
    &quot;&quot;&quot;Sets the title of the document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setUserData(self, data: object) -&gt; None</code>
            <code><span class="kw">def</span> transactionManager(self) -&gt; TransactionManager
    &quot;&quot;&quot;This function returns the AcTransactionManager object for this AcApDocument. The global
function actrTransactionManager() will return a pointer to the current document&#x27;s
transaction manager. This function is important because an application cannot mix objects
from different documents in the same transaction. If an application is opening objects from
more than one document at a time, and are using transactions, they must start a separate
transaction for each document, using the transaction manager from each document.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> upgradeDocOpen(self) -&gt; None
    &quot;&quot;&quot;Converts the document status from read only to write, if possible.&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="LayerFilter">
        <details>
            <summary>class LayerFilter <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;This is the main layer filter class. It allows the client to specify and retrieve the
filter expression and to nest filters. The following rules apply when deriving custom
filters from AcLyLayerFilter: Define the class using the ACRX_CONS_DEFINE_MEMBERS macro,
not ACRX_DXF_DEFINE_MEMBERS.Don&#x27;t forget to call rxInit().When implementing readFrom() and
writeTo(), don&#x27;t use any of the DXF subclass marker functionality of the filer, as this
will make DXF files invalid.DXF subclass functionality includes
pFiler-&gt;writeItem(AcDb::kDxfSubclass, ...) and pFiler-&gt;atSubclassData(...).For custom
(AcLyLayerFilter-derived) filter classes, the readLegacyFrom() and writeLegacyTo() methods
are never called because custom filters cannot be represented in AutoCAD 2004 and previous
releases.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addNested(self, val: PyAp.LayerFilter) -&gt; None
    &quot;&quot;&quot;Adds the filter to this filter as a nested filter. Returns Acad::eNotApplicable when
allowNested() is false. Returns Acad::eInvalidInput when filter is null. Returns Acad::eOk
when successful.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> allowDelete(self) -&gt; bool
    &quot;&quot;&quot;Returns true if this filter can be removed.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> allowNested(self) -&gt; bool
    &quot;&quot;&quot;Returns true if this filter allows nested filters.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> allowRename(self) -&gt; bool
    &quot;&quot;&quot;Returns a Boolean value indicating whether or not renaming this filter is allowed.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> compareTo(self, other: PyAp.LayerFilter) -&gt; bool
    &quot;&quot;&quot;Returns true if this filter and pOther allow the same layers.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> dynamicallyGenerated(self) -&gt; bool
    &quot;&quot;&quot;When implemented in a derived class, this function should return true if the filter is
dynamically generated by its parent and should not be persisted on its own.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> filter(self, val: PyDb.LayerTableRecord) -&gt; bool
    &quot;&quot;&quot;Returns true if the given AcDbLayerTableRecord is visible with this filter.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> filterExpression(self) -&gt; str
    &quot;&quot;&quot;Returns a filter expression of this form: /* BNF for the valid boolean expression we
evaluate &lt;bool_expr&gt;::= &lt;bool_expr&gt; or &lt;and_expr&gt; | &lt;and_expr&gt; &lt;and_expr&gt;::=&lt;and_expr&gt; and
&lt;rel_expr&gt; | &lt;rel_expr&gt; &lt;rel_expr&gt;::=&lt;variable&gt;&lt;rel_op&gt;&lt;constant&gt; &lt;rel_op&gt;::= == | !=
&lt;constant&gt;::=A-Z0-9*?~@.,- &lt;variable&gt;::=#A-Z0-9 */This function may return null if the
filter cannot be described this way.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> generateNested(self) -&gt; None
    &quot;&quot;&quot;Called by the ObjectDBX framework after a filter is loaded from persistent storage. This is
an opportunity for the filter to generate nested filters. Should return Acad::eOk if
successful. Any other return value will abort the loading of this filter and the filter
will not be added to the filter tree.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getNestedFilters(self) -&gt; list[PyAp.LayerFilter]
    &quot;&quot;&quot;Returns an array containing the nested filters of this filter. The returned array is const;
clients should not remove or add filters to this array.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isIdFilter(self) -&gt; bool
    &quot;&quot;&quot;Returns true if this filter only filters for the object ID property of a layer. These
filters are also known as layer groups.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isProxy(self) -&gt; bool
    &quot;&quot;&quot;Returns true if this is a proxy filter. A filter becomes a proxy when ObjectDBX does not
find the code (ObjectARX or ObjectDBX application) behind the filter. Proxy filters are not
shown to the user by AutoCAD, but their persistent data is round tripped.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> name(self) -&gt; str
    &quot;&quot;&quot;Returns the name of the filter. This usually what is entered by the user when filter is
created. However, for some filters such as the Xref or All filter, this is a localized
constant.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> parent(self) -&gt; LayerFilter
    &quot;&quot;&quot;Returns the parent filter for this filter. All filters except the top level (&#x27;All&#x27;) filter
have a parent. The top level filter returns null.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> removeNested(self, val: PyAp.LayerFilter) -&gt; None
    &quot;&quot;&quot;Removes the given filter from the list of nested filters for this filter. Returns Acad::eOk
when successful. Returns Acad::eNotApplicable when filter-&gt;allowDelete() is false. Returns
Acad::eInvalidInput when filter is null.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setFilterExpression(self, val: str) -&gt; None
    &quot;&quot;&quot;Sets a new filter expression. See filterExpression() for valid filter expressions. Returns
eNotApplicable if the filter is not expression-based. Returns eInvalidInput if the
expression is invalid. Returns eOk otherwise.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setName(self, val: str) -&gt; None
    &quot;&quot;&quot;Sets the name of the filter. If renaming is not allowed, this function returns
Acad::eNotApplicable. If the name is null, then it returns Acad::eInvalidInput. Returns
Acad::eOk when successful.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showEditor(self) -&gt; int
    &quot;&quot;&quot;Called by the host application to show an editor window for the filter. The editor is
displayed as a child of the active popup window. Return kUseDefault if you want to instruct
the host application to display the default filter dialog.&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="LayerFilterManager">
        <details>
            <summary>class LayerFilterManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, db: PyDb.Database) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> getFilters(self) -&gt; tuple[PyAp.LayerFilter, PyAp.LayerFilter]</code>
            <code><span class="kw">def</span> setFilters(self, root: PyAp.LayerFilter, current: PyAp.LayerFilter) -&gt; None</code>
            <code><span class="kw">def</span> setFilters(self, rootCurrent: tuple[PyAp.LayerFilter, PyAp.LayerFilter]) -&gt; None</code>
            <code><span class="kw">def</span> setFilters(*args) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="LayerGroup">
        <details>
            <summary>class LayerGroup <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addLayerId(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> layerIds(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> removeLayerId(self, id: PyDb.ObjectId) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="LayoutManager">
        <details>
            <summary>class LayoutManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;Interface class for application-specific routines that manipulate and access AcDbLayout
objects. This class also controls layout related GUI attributes.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> createLayoutFromTemplate(self, newLayoutName: str, templatePath: str, layoutName: str, db: PyDb.Database) -&gt; PyDb.ObjectId
    &quot;&quot;&quot;Creates a new layout from an existing layout that is stored in a drawing or drawing
template file.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> createViewports(self) -&gt; bool
    &quot;&quot;&quot;This function returns kTrue if a viewport will be created by default in a paper space
layout, and kFalse otherwise.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> generateNextNewLayoutName(self, val: PyDb.Database) -&gt; str
    &quot;&quot;&quot;This function scans the existing layouts (included deleted ones) for name matches of the
type &#x27;Layout#&#x27; where # is a number starting at 1 and increasing. The function starts with
Layout1 and keeps trying to find one that isn&#x27;t already used in this format and then
returns it.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getActiveTab(self) -&gt; str
    &quot;&quot;&quot;This function returns the name of the currently selected layout tab which is also the name
of the current AcDbLayout object.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getClipBoundaryElabration(self, val: PyDb.ObjectId) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> pageSetup(self, layoutBTRId: PyDb.ObjectId, parent: int, isPageSetupDlg: bool) -&gt; int
    &quot;&quot;&quot;By default, this function launches the Page Setup dialog with the current AcDbLayout
object. Optionally, this function takes arguments to initialize it with a different
AcDbLayout object, a pointer to a different parent window, and whether to bring up the
shared Plot dialog instead of the Page Setup dialog. The function returns O if the Page
Setup dialog has been canceled; 1 if the the Page Setup dialog has succeeded; and -1 for
any error conditions.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pointInViewports(self, val: PyGe.Point3d) -&gt; list[PyDb.ObjectId]
    &quot;&quot;&quot;This function takes a Paperspace pick point, and passes back a list, in the form of an
AcDbObjectIdArray, of the AcDbObjectId entities of every AcDbViewport that overlays the
pick point, including non-rectangular viewports. If viewports overlap each other at the
pick point, all of them will be returned, but the first AcDbViewport Id in the array will
be the viewport that would be selected if the user double-clicked at the point. The
PaperSpace viewport will never be included in the array. If no viewports are at the pick
point, ePointNotOnEntity will be returned, and the AcDbObjectIdArray will not be created.
If at least one viewport is in the array, eOk will be returned. The caller must delete the
returned AcDbObjectIdArray when finished with it. This routine allows an application to
easily determine if a given point lies within a non-rectangular (clipped) viewport.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setCaptureOnLayoutSwitch(self, val: bool) -&gt; None
    &quot;&quot;&quot;Controls whether a thumbnail is generated for a layout after it has been set active. An
argument of kTrue enables the generation of the thumbnail; kFalse disables the generation
of the thumbnail.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setCreateViewports(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function establishes whether a viewport is created by default on initial entry into a
paper space layout.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setDefaultPlotConfig(self, val: PyDb.ObjectId) -&gt; None
    &quot;&quot;&quot;This function sets appropriate defaults for the AcDbLayout associated with the given
AcDbBlockTableRecord.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setShowPageSetup(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function sets whether the Page Setup dialog is launched upon initial entry into a
paper space layout tab.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setShowPaperBackground(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function sets whether the paper shadow is visible for the current or active AcDbLayout
object. An argument of kTrue sets the paper shadow visible; kFalse makes it invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setShowPaperMargins(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function sets whether the printable area or paper margin (the dashed rectangle) is
visible for the current or active AcDbLayout object. An argument of kTrue sets the paper
margin visible; kFalse makes it invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setShowPrintBorder(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function sets whether the print border (paper boundary) is visible for the current or
active AcDbLayout object. An argument of kTrue sets the print border visible; kFalse makes
it invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setShowTabs(self, val: bool) -&gt; None
    &quot;&quot;&quot;This function sets whether the layout tabs are visible. An argument of kTrue sets the
layout tabs to be visible; kFalse makes them invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showPageSetup(self) -&gt; bool
    &quot;&quot;&quot;This function returns whether the Page Setup dialog is automatically launched upon initial
entry into a paper space layout. A return of 1 indicates it is launched; 0, it isn&#x27;t.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showPaperBackground(self) -&gt; bool
    &quot;&quot;&quot;This function sets whether the Page Setup dialog is launched upon initial entry into a
paper space layout tab.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showPaperMargins(self) -&gt; bool
    &quot;&quot;&quot;This function returns whether the current AcDbLayout object&#x27;s paper margins are visible. A
return of 1 indicates it&#x27;s visible; 0, invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showPrintBorder(self) -&gt; bool
    &quot;&quot;&quot;This function returns whether the current AcDbLayout object&#x27;s print border is visible. A
return of 1 indicates it&#x27;s visible; 0, invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showTabs(self) -&gt; bool
    &quot;&quot;&quot;This function returns whether the layout tabs are visible. A return of 1 indicates they&#x27;re
visible; 0, invisible.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> updateCurrentPaper(self, zoomToPaper: bool) -&gt; None
    &quot;&quot;&quot;This function updates the paper space paper image to reflect the current state of the
active AcDbLayout object. Optionally, an argument of kTrue can be passed in to perform a
zoom to change the view to the extents of the paper image boundary.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> updateLayoutTabs(self) -&gt; None
    &quot;&quot;&quot;This function regenerates the layout tabs to update them to the current state of the
AcDbLayout objects they represent.&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="Palette">
        <details>
            <summary>class Palette <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> getWxWindow(self) -&gt; object</code>
        </details>
    </div>

    <div class="class" id="PaletteDockStyle">
        <details>
            <summary>class PaletteDockStyle <span class="tag">Class</span></summary>
            <code>kNone: ClassVar[Self]</code>
            <code>kLeft: ClassVar[Self]</code>
            <code>kRight: ClassVar[Self]</code>
            <code>kTop: ClassVar[Self]</code>
            <code>kBottom: ClassVar[Self]</code>
            <code>kAny: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="PaletteSet">
        <details>
            <summary>class PaletteSet <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, name: str, guid: str) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> add(self, name: str, panel: wx.Panel) -&gt; int</code>
            <code><span class="kw">def</span> anchored(self) -&gt; bool</code>
            <code><span class="kw">def</span> autoRollupStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_AUTO_ROLLUP style set; otherwise, returns
false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> closeButtonStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_CLOSE_BUTTON style set; otherwise, returns
false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> dockControlBar(self, style: PyAp.PaletteDockStyle, rect: tuple[int, int, int, int]) -&gt; None</code>
            <code><span class="kw">def</span> editNameStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette has the PS_EDIT_NAME style set; otherwise, returns false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> enableDocking(self, style: PyAp.PaletteDockStyle) -&gt; None</code>
            <code><span class="kw">def</span> getActivePaletteTabIndex(self) -&gt; int
    &quot;&quot;&quot;Returns the zero-based tab index of the currently active palette.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getAutoRollup(self) -&gt; bool
    &quot;&quot;&quot;Returns true if auto rollup is enabled. Returns false if it is disabled or if the the
auto-rollup style is not set for the palette set.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getDockState(self) -&gt; PaletteDockStyle</code>
            <code><span class="kw">def</span> getFloatingRect(self) -&gt; tuple[int, int, int, int]</code>
            <code><span class="kw">def</span> getFullRect(self) -&gt; object
    &quot;&quot;&quot;Gets the full window rectangle of the palette set. This function retrieves the rectangle of
the unrolled palette set even if the palette set is currently rolled up.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getName(self) -&gt; str
    &quot;&quot;&quot;Returns the name of the palette set.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getOpacity(self) -&gt; int
    &quot;&quot;&quot;Returns the current opacity for the palette set. Valid values are in the range 0 to 100,
where 0 is completely transparent and 100 is completely opaque.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getPaletteCount(self) -&gt; int
    &quot;&quot;&quot;Returns the number of palettes in the palette set.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getPaletteSetStyle(self) -&gt; int
    &quot;&quot;&quot;Returns the palette set style, which is a combination of the CAdUiPaletteSet palette style
constants.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getRolloverOpacity(self) -&gt; int
    &quot;&quot;&quot;Returns the rollover opacity value.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getWxWindow(self) -&gt; object</code>
            <code><span class="kw">def</span> hidePalettes() -&gt; bool</code>
            <code><span class="kw">def</span> initFloatingPosition(self, rect: tuple[int, int, int, int]) -&gt; None</code>
            <code><span class="kw">def</span> isFloating(self) -&gt; bool</code>
            <code><span class="kw">def</span> paletteBackgroundColor(self) -&gt; int</code>
            <code><span class="kw">def</span> paletteTabTextColor(self) -&gt; int</code>
            <code><span class="kw">def</span> propertiesMenuStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_PROPERTIES_MENU style set; otherwise, returns
false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> removePalette(self, val: int) -&gt; bool
    &quot;&quot;&quot;Removes the palette specified by nPaletteIndex from the palette set. Returns true if the
palette was successfuly removed; otherwise, returns false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> restoreControlBar(self) -&gt; None</code>
            <code><span class="kw">def</span> restoreControlBar(self, style: PyAp.PaletteDockStyle, rect: tuple[int, int, int, int]) -&gt; None</code>
            <code><span class="kw">def</span> restoreControlBar(*args) -&gt; None</code>
            <code><span class="kw">def</span> rollOut(self, delay: bool) -&gt; None
    &quot;&quot;&quot;Triggers a roll out of the palette set if auto-rollup is on and the palette set is not
docked. If bDelay is true, the palette set will use an extended rollup delay time. When the
parameter is false, the palette set will use the normal delay time for rolling up.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> rollUp(self) -&gt; None
    &quot;&quot;&quot;Triggers a roll up of the palette set if auto-rollup is on and the palette set is not
docked.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> rolledUp(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set is rolled up; returns false if it is unrolled.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setActivePalette(self, val: int) -&gt; bool
    &quot;&quot;&quot;Sets the palette specified by nPaletteIndex to be the currently active palette.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setAutoRollup(self, val: bool) -&gt; bool
    &quot;&quot;&quot;Enables and disables auto rollup for the palette set. Setting the auto-rollup state also
causes the palette set to react as necessary. For example, it will roll out if auto rollup
is disabled and may roll up, depending on the cursor position, if auto rollup is enabled.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setDockState(self, style: PyAp.PaletteDockStyle) -&gt; None</code>
            <code><span class="kw">def</span> setLocation(self, x: int, y: int) -&gt; None</code>
            <code><span class="kw">def</span> setName(self, name: str) -&gt; bool
    &quot;&quot;&quot;Sets the name of the palette set. Returns true if the palette set name is successfully set
to pszName; otherwise, returns false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setOpacity(self, val: int) -&gt; bool
    &quot;&quot;&quot;Sets the opacity for the palette set. the opacity must be in the range 0 to 100, where 0 is
completely transparent and 100 is completely opaque.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setPaletteSetStyle(self, val: int) -&gt; None
    &quot;&quot;&quot;Sets the palette set style.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setRolloverOpacity(self, val: int) -&gt; bool
    &quot;&quot;&quot;Sets the value of the rollover opacity. Returns true if successful.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setSize(self, x: int, y: int) -&gt; None</code>
            <code><span class="kw">def</span> setTitleBarLocation(self, val: PyAp.PaletteTitleBarLocation) -&gt; None
    &quot;&quot;&quot;Sets the title bar orientation (left or right) for the palette set.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setToolId(self, guid: str) -&gt; bool
    &quot;&quot;&quot;Sets the identifier associated with a control bar. Since a control identifier needs to be
unique, class IDs are used for that purpose. You can generate a class ID using the system
utility GUIDGEN. A good place to call this method is right after you called the Create()
method. It must be called before RestoreControlBar() because the persistency system relies
on the control bar IDs.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setVisible(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> showIconStyle(self) -&gt; bool
    &quot;&quot;&quot;This is ShowIconStyle, a member of class CAdUiPaletteSet.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> showPalettes() -&gt; bool</code>
            <code><span class="kw">def</span> showRollupButtonStyle(self) -&gt; bool
    &quot;&quot;&quot;This is ShowRollupButtonStyle, a member of class CAdUiPaletteSet.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> singlePaletteTabStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_SINGLE_PALETTE_TAB style set; otherwise,
returns false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> snapStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_SNAP style set; otherwise, returns false.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> titleBarLocation(self) -&gt; PaletteTitleBarLocation
    &quot;&quot;&quot;Returns the current location of the palette set title bar, either kRight or kLeft.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> updateTabs(self) -&gt; None
    &quot;&quot;&quot;Updates the palette set&#x27;s tab display. The base palette implementation calls this function
when a palette name changes.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> useSinglePaletteTabNameStyle(self) -&gt; bool
    &quot;&quot;&quot;Returns true if the palette set has the PSS_USE_SINGLE_PALETTE_TAB_NAME style set.&quot;&quot;&quot;</code>
        </details>
    </div>

    <div class="class" id="PaletteTitleBarLocation">
        <details>
            <summary>class PaletteTitleBarLocation <span class="tag">Class</span></summary>
            <code>kLeft: ClassVar[Self]</code>
            <code>kRight: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="PyRxTestFlags">
        <details>
            <summary>class PyRxTestFlags <span class="tag">Class</span></summary>
            <code>kNoOptimize: ClassVar[Self]</code>
            <code>kPyReserved1: ClassVar[Self]</code>
            <code>kPyReserved2: ClassVar[Self]</code>
            <code>kPyReserved3: ClassVar[Self]</code>
            <code>kPyReserved4: ClassVar[Self]</code>
            <code>kPyReserved5: ClassVar[Self]</code>
            <code>kPyReserved6: ClassVar[Self]</code>
            <code>kPyReserved7: ClassVar[Self]</code>
            <code>kWaitForDebug: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ResourceOverride">
        <details>
            <summary>class ResourceOverride <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;Use an instance of this class to switch between default and module&#x27;s resources. When the
object is constructed, a new resource provider will be switched in. Upon destruction the
original resource provider will be restored. For example: void MyFunc() {
CAcModuleResourceOverride myResources; . . }Upon entry to this function, the module&#x27;s
resources will be selected. When the function returns, the default resources will be
restored. A resource override can be used in any of three ways: Use the default constructor
(no arguments) to switch to the module&#x27;s resources. The default resources will be restored
by the destructor. The module/default resources are those maintained by the DLL&#x27;s
CAcExtensionModule.Pass NULL (or 0) to the constructor. The DLL&#x27;s resources will be
selected and the resources that were in effect will be restored when the override object is
destroyed.Pass a non-NULL handle to the constructor. The associated module&#x27;s resources will
be selected and the resources that were in effect will be restored when the override object
is destroyed.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
        </details>
    </div>

    <div class="class" id="SaveFormat">
        <details>
            <summary>class SaveFormat <span class="tag">Class</span></summary>
            <code>kUnknown: ClassVar[Self]</code>
            <code>kR12_dxf: ClassVar[Self]</code>
            <code>kR13_dwg: ClassVar[Self]</code>
            <code>kR13_dxf: ClassVar[Self]</code>
            <code>kR14_dwg: ClassVar[Self]</code>
            <code>kR14_dxf: ClassVar[Self]</code>
            <code>k2000_dwg: ClassVar[Self]</code>
            <code>k2000_dxf: ClassVar[Self]</code>
            <code>k2000_Template: ClassVar[Self]</code>
            <code>k2000_Standard: ClassVar[Self]</code>
            <code>k2000_xml: ClassVar[Self]</code>
            <code>k2004_dwg: ClassVar[Self]</code>
            <code>k2004_dxf: ClassVar[Self]</code>
            <code>k2004_Template: ClassVar[Self]</code>
            <code>k2004_Standard: ClassVar[Self]</code>
            <code>k2007_dwg: ClassVar[Self]</code>
            <code>k2007_dxf: ClassVar[Self]</code>
            <code>k2007_Template: ClassVar[Self]</code>
            <code>k2007_Standard: ClassVar[Self]</code>
            <code>k2010_dwg: ClassVar[Self]</code>
            <code>k2010_dxf: ClassVar[Self]</code>
            <code>k2010_Template: ClassVar[Self]</code>
            <code>k2010_Standard: ClassVar[Self]</code>
            <code>k2013_dwg: ClassVar[Self]</code>
            <code>k2013_dxf: ClassVar[Self]</code>
            <code>k2013_Template: ClassVar[Self]</code>
            <code>k2013_Standard: ClassVar[Self]</code>
            <code>k2018_dwg: ClassVar[Self]</code>
            <code>k2018_dxf: ClassVar[Self]</code>
            <code>k2018_Template: ClassVar[Self]</code>
            <code>k2018_Standard: ClassVar[Self]</code>
            <code>kNative: ClassVar[Self]</code>
            <code>kNative_Template: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TransactionManager">
        <details>
            <summary>class TransactionManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None
    &quot;&quot;&quot;There is a single object of class AcTransactionManager created by the ObjectARX system when
AutoCAD first starts up. This AcTransactionManager object is globally available to all
ObjectARX applications. The macro actrTransactionManager returns a pointer to the system
AcTransactionManager object to allow access to its member functions. The system
AcTransactionManager object is used to start, end, or terminate transactions. In addition,
it provides functionality to manage transactions and the objects within them. For more
information on the transaction mechanism, see the transaction section in the ObjectARX
Developer&#x27;s Guide.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> enableGraphicsFlush(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> flushGraphics(self) -&gt; None</code>
        </details>
    </div>
</body>
</html>